const rev_count: int = 5 
const init_right_turn_count: int = 13

const rev_speed: int = 80
const right_turn_speed: int = 90
const left_turn_speed: int = 90
const diff_offset : int = 5

const pid_fwd_speed: int = 80
const fwd_speed: int = 40

const i_kp: int = 1
const i_kd: int  = 120
const i_ki: int  = 10000

const max_drive: int = 110

node obstavoider(ir_d_front, ir_d_left1, ir_d_left2: bool;  penc_l, penc_r: int;) 
   returns (v_left, v_right, cs: int)  
   (*  
     0 - forward 
     1 - back
     2 - left turn 
     3 - right turn
     4 - soft left
     5 - soft right
     6 - stop 
   *) 
 var 
 (* last oas_busy: bool = false; 
 last timer: int; *)
 last current_state: int; 
 (* last penc_l_target: int;
 last penc_r_target: int; *)
 let 
   (* this is to check which state fsm is in, add primary cs to primary output and uncomment below line *) 
   cs = current_state; 
  
  automaton
    state PIDFollower
      var error_sum, raw_drive, drive, error: int;
      do
        error = if(ir_d_left1) then (if(ir_d_left2) then 15 else 30) else (if(ir_d_left2) then -40 else -15);
        error_sum = 0 -> (pre(error_sum) + error);
        raw_drive = ( error - ( 0 -> pre(error)  )) / i_kd +  error / i_kp + error_sum / i_ki;
        current_state = error;
    
        drive = if(raw_drive > max_drive) then max_drive else if(raw_drive < 0-max_drive) then 0-max_drive else raw_drive;
        v_left = pid_fwd_speed - drive;
        v_right = pid_fwd_speed + drive;
  end
 tel
