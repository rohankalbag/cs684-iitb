const white_threshold: int = 800
const start_fwd_speed: int = 70

const rev_count: int = 5 (*no of pulses to reverse for*)
const init_left_turn_count: int = 13 (*rot encoder pulses threshold*)
const rev_speed: int = 80
const fwd_speed: int = 80
const right_turn_speed: int = 90
const left_turn_speed: int = 120

const pid_fwd_speed_wall: int = 70
const i_kp_wall: int = 1
const i_kd_wall: int  = 120
const i_ki_wall: int  = 10000
const max_drive_wall: int = 110


const i_kp_line: int = 1
const i_kd_line: int  = 140
const i_ki_line: int  = 10000
const w_far: int = 2
const w_cent: int = 30
const pid_fwd_speed_line: int = 40
const max_drive_line: int = 110



node pidline(cfr, ccr, ccc, ccl, cfl: int) 
  returns (v_left, v_right: int)
  var error_sum, raw_drive, drive, error: int;
  let
    error = cfr / w_far + ccr / w_cent - ccl / w_cent - cfl / w_far ;
    error_sum = 0 -> (pre(error_sum) + error);
    raw_drive = (error - (0 -> pre(error))) / i_kd_line +  error / i_kp_line + error_sum / i_ki_line;

    drive = if(raw_drive > max_drive_line) then max_drive_line else if(raw_drive < 0-max_drive_line) then 0-max_drive_line else raw_drive;
    v_left = pid_fwd_speed_line - drive;
    v_right = pid_fwd_speed_line + drive;
  tel

node pidwallalign(ir_d_left1, ir_d_left2: bool) 
  returns (v_left, v_right: int)  
  var error_sum, raw_drive, drive, error: int;
  let
    error = if(ir_d_left1) then (if(ir_d_left2) then 15 else 30) else (if(ir_d_left2) then -40 else -15);
    error_sum = 0 -> (pre(error_sum) + error);
    raw_drive = ( error - ( 0 -> pre(error)  )) / i_kd_wall +  error / i_kp_wall + error_sum / i_ki_wall;
    drive = if(raw_drive > max_drive_wall) then max_drive_wall else if(raw_drive < 0-max_drive_wall) then 0-max_drive_wall else raw_drive;
    v_left = pid_fwd_speed_wall - drive;
    v_right = pid_fwd_speed_wall + drive;
  tel

node obstacleavoider(ir_d_left1, ir_d_left2, white_line: bool; penc_l, penc_r:int)
  returns (v_left, v_right: int; oas_done: bool)
  
  var last timer: int;
  last penc_l_target: int;
  last penc_r_target: int;
  
  let
     automaton  
        
        state Reverse_1
        do 
          penc_l_target = (penc_l + rev_count) -> pre(penc_l_target);
          penc_r_target = (penc_r + rev_count) -> pre(penc_r_target);
          v_left = if(penc_l < penc_l_target) then -rev_speed else 0;
          v_right = if(penc_r < penc_r_target) then -rev_speed else 0;
          oas_done = false;
        until (penc_l >= penc_l_target and penc_r >= penc_r_target) then  LeftTurn_1

        
        state LeftTurn_1 do
          penc_r_target = (penc_r + init_left_turn_count) -> pre(penc_r_target);
          v_left = 0;
          v_right = if(penc_r < penc_r_target) then left_turn_speed else 0;
          oas_done = false;
        until (penc_r >= penc_r_target ) then Delay_2

        state Delay_2
        do
          v_left = 0;
          v_right = 0;
          timer = 100 -> pre(timer) - 1;
          oas_done = false;
        until timer <= 0 then PIDWallFollower

      

        state PIDWallFollower
        do
          (v_left, v_right) = pidwallalign(ir_d_left1, ir_d_left2);
          oas_done = false;
        until white_line then ExitState

        state ExitState
        do
          v_left = 0;
          v_right = 0;
          oas_done = true;
      end 
  tel

node finallogic(cfr, ccr, ccc, ccl, cfl, penc_l, penc_r: int; ir_d_front, ir_d_left1, ir_d_left2: bool) 
   returns (v_left, v_right, cs: int)
   var last current_state: int;
   let
    cs = current_state;
  automaton
    state StartState
    do
      v_left = 100;
      v_right = 100;
      current_state = 1;
    until cfr < white_threshold or ccr < white_threshold or ccc < white_threshold or ccl < white_threshold or cfl < white_threshold then WhiteLineFollower

    state WhiteLineFollower
    do
      automaton
        state LineFollowing
        do
          current_state = 2;
          (v_left, v_right) = pidline(cfr, ccr, ccc, ccl, cfl);
        until ir_d_front then ObstacleAvoider
        state ObstacleAvoider
          var oas_done, white_line: bool;

        do
          current_state = 3;
          white_line = cfr >= white_threshold or ccr >= white_threshold or ccc >= white_threshold or ccl >= white_threshold or cfl >= white_threshold;
          (v_left, v_right, oas_done) = obstacleavoider(ir_d_left1, ir_d_left2, white_line, penc_l, penc_r);
        until oas_done then LineFollowing
  
      end
   
  end
tel